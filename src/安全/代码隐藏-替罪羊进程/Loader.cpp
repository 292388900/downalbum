// Loader.cpp : Defines the entry point for the console application.
//

/*
时间：2011年2月12日
作者：angelkiss
函数功能：Reload And Run程序目录下的test.exe程序
*/

#include "stdafx.h"
#include <afx.h>
#include <iostream>
#include <tchar.h>
#include <afxwin.h>
#include <Psapi.h>
#include <shlwapi.h>

//#include "ntimage.h"
#include "Loader.h"

using namespace std;


#pragma comment(lib,"Psapi.lib")
#pragma comment(lib,"shlwapi.lib")


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CString GetStartPath()
{
	TCHAR szTemp[MAX_PATH*2];
	GetModuleFileName(NULL,szTemp,sizeof(szTemp)/sizeof(TCHAR));
	StrRChr(szTemp,NULL,'\\')[1]=0;
	return szTemp;
}

int main(int argc, char* argv[])
{
	CString strStartPath=GetStartPath();
	//CString strTargetFile=_T("C:\\windows\\notepad.exe");
	CString strTargetFile=strStartPath+_T("notepad.exe");

	//打开test.exe文件，并读取文件内容
	TCHAR szDllFile[MAX_PATH] = {0};
	GetModuleFileName(NULL,szDllFile,_countof(szDllFile));
#ifdef _DEBUG
	lstrcpy(&StrRChr(szDllFile,NULL,'\\')[1],_T("dllexe.dll"));
#else
	lstrcpy(&StrRChr(szDllFile,NULL,'\\')[1],_T("dllexe.dll"));
#endif


	//首先获取目标exe的OEP
	//////////////////////////////////////////////////////////////////////////

	HANDLE hFile=CreateFile(strTargetFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if ( hFile==INVALID_HANDLE_VALUE ){
		AfxMessageBox(_T("打开文件失败"));
		return -1;
	}

	DWORD size_low,size_high;
	size_low= GetFileSize(hFile,&size_high); 

	HANDLE hMap=CreateFileMapping(hFile,NULL,PAGE_READONLY,size_high,size_low,NULL);
	if ( hMap==NULL ){
		AfxMessageBox(_T("CreateFileMapping失败"));
		CloseHandle(hFile);
		return -1;
	}

	PBYTE pFile=(PBYTE)MapViewOfFile(hMap,FILE_MAP_READ,0,0,0);
	if ( pFile==NULL ){
		AfxMessageBox(_T("MapViewOfFile失败"));
		CloseHandle(hMap);
		CloseHandle(hFile);
		return -1;
	}

	PIMAGE_DOS_HEADER pDosHdr=(PIMAGE_DOS_HEADER)pFile;
	PIMAGE_NT_HEADERS pNtHdr=(PIMAGE_NT_HEADERS)((PBYTE)pDosHdr+pDosHdr->e_lfanew);
	DWORD dwImageSize=pNtHdr->OptionalHeader.SizeOfImage;
	DWORD dwImageBase=pNtHdr->OptionalHeader.ImageBase;
	DWORD dwEP=pNtHdr->OptionalHeader.AddressOfEntryPoint+dwImageBase;

	UnmapViewOfFile(pFile);
	CloseHandle(hMap);
	CloseHandle(hFile);

	//以调试的方式创建notepad进程
	//////////////////////////////////////////////////////////////////////////
	STARTUPINFO si={sizeof(si)};
	PROCESS_INFORMATION pi;
	//使用DETACHED_PROCESS标志是为了不让子进程拥有父进程的控制台窗口
	CreateProcess(strTargetFile,NULL,NULL,NULL,FALSE,DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS|DETACHED_PROCESS,NULL,NULL,&si,&pi);
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	CString strText;
	BOOL bPatched=FALSE;
	DEBUG_EVENT stDbgevent;
	CONTEXT stThreadContext;
	DWORD dwProcessId;
	LPVOID lpImageBase;
	HANDLE hProcess;
	HANDLE hThread;
	LPVOID lpEntryPoint;
	DWORD dwReadWrite;
	while ( TRUE ){
		if ( WaitForDebugEvent(&stDbgevent,INFINITE)==0 ){
			//failed
			break;
		}

		if ( stDbgevent.dwDebugEventCode==CREATE_PROCESS_DEBUG_EVENT ){			//被调试进程刚被创建

			//获取一些基本信息
			dwProcessId=stDbgevent.dwProcessId;
			lpImageBase=stDbgevent.u.CreateProcessInfo.lpBaseOfImage;
			lpEntryPoint=stDbgevent.u.CreateProcessInfo.lpStartAddress;
			hProcess=stDbgevent.u.CreateProcessInfo.hProcess;
			hThread=stDbgevent.u.CreateProcessInfo.hThread;

			//在入口处写个int3断点
			BYTE bInt3='\xCC';
			WriteProcessMemory(hProcess,lpEntryPoint,&bInt3,sizeof(BYTE),&dwReadWrite);
			FlushInstructionCache(hProcess,lpEntryPoint,1);	//将代码写入内存让cpu执行
			ContinueDebugEvent(stDbgevent.dwProcessId, stDbgevent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED ); 

		}else if ( stDbgevent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT ){	//调试结束
			break;
		}else if ( stDbgevent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT ){
			if ( stDbgevent.u.Exception.ExceptionRecord.ExceptionCode==EXCEPTION_BREAKPOINT 
				&& stDbgevent.u.Exception.ExceptionRecord.ExceptionAddress==lpEntryPoint ){
				//当异常发生在入口处时，是我们下的int3断点，可以patch代码了

				stThreadContext.ContextFlags=CONTEXT_CONTROL;
				GetThreadContext(hThread,&stThreadContext);

				//patch代码，设置新的EIP
				stThreadContext.Eip=PatchCode(hProcess,lpImageBase,dwImageSize,szDllFile);
				SetThreadContext(hThread,&stThreadContext);

				//我们的目标达成了，detach进程让它跑起来
				ContinueDebugEvent(stDbgevent.dwProcessId, stDbgevent.dwThreadId, DBG_CONTINUE); 
				DebugActiveProcessStop(stDbgevent.dwProcessId);
				break;
			}else{
				//以DBG_CONTINUE标志继续进行调试
				ContinueDebugEvent(stDbgevent.dwProcessId, stDbgevent.dwThreadId, DBG_CONTINUE); 
			}

		}else{	//其他情况不处理
			ContinueDebugEvent(stDbgevent.dwProcessId, stDbgevent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED); 
		}

	}

	system("pause");
	return 0;
}

DWORD PatchCode(HANDLE hTargetProcess,LPVOID lpImageBase,DWORD dwImageSize,LPCTSTR lpszFilePath)
{
	DWORD dwNewEip=0;

	//修改页保护属性
	DWORD dwOldProtect=0;
	if ( !VirtualProtectEx(hTargetProcess,lpImageBase, dwImageSize, PAGE_EXECUTE_READWRITE, &dwOldProtect) ){
		AfxMessageBox(_T("VirtualProtect失败"));
		return dwNewEip;
	}
	
	HANDLE hFile = CreateFile(lpszFilePath,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	DWORD dwErr = GetLastError();
	if( hFile == INVALID_HANDLE_VALUE ){
		AfxMessageBox(_T("打开文件失败"));
		return dwNewEip;
	}

	DWORD dwFileSize = GetFileSize( hFile, NULL );
	if( dwFileSize == INVALID_FILE_SIZE ){
		AfxMessageBox(_T("获取文件大小失败"));
		CloseHandle(hFile);
		return dwNewEip;
	}

	//分配足够大的空间，将文件读入
	PVOID pBuffer = (PVOID)new BYTE[dwFileSize];
	if( pBuffer == NULL ){
		AfxMessageBox(_T("申请存放文件内容空间失败"));
		CloseHandle( hFile );
		return dwNewEip;
	}

	DWORD dwReadWrite = 0;
	if( ReadFile(hFile,pBuffer,dwFileSize,&dwReadWrite,NULL)==FALSE ){
		AfxMessageBox(_T("读取文件内容失败"));
		delete []pBuffer;
		CloseHandle( hFile );
		return dwNewEip;
	}

	//计算文件内存对齐后的大小
	DWORD dwSrcImgSize = GetTotalImageSize(pBuffer,dwFileSize);
	if ( dwSrcImgSize==0 ){
		AfxMessageBox(_T("GetTotalImageSize失败"));
		delete []pBuffer;
		CloseHandle( hFile );
		return dwNewEip;
	}

	//计算目标基址
	PVOID lpNewImgBase=NULL;
	if ( dwSrcImgSize<=dwImageSize ){	//说明可以直接patch代码
		lpNewImgBase=lpImageBase;
	}else{	//空间不够开辟内存
		lpNewImgBase=VirtualAllocEx(hTargetProcess,NULL,dwSrcImgSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
		if ( lpNewImgBase==NULL ){
			AfxMessageBox(_T("VirtualAllocEx失败"));
			delete []pBuffer;
			CloseHandle( hFile );
			return dwNewEip;
		}
	}

	//先映射到当前进程中，最后直接写到目标进程
	PVOID pImageBuffer=VirtualAllocEx(::GetCurrentProcess(),NULL,dwSrcImgSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
	if ( lpNewImgBase==NULL ){
		AfxMessageBox(_T("VirtualAllocEx失败"));
		delete []pBuffer;
		CloseHandle( hFile );
		return dwNewEip;
	}

	//首先将节按内存对齐值对齐
	AlignFileToMem(pImageBuffer,dwSrcImgSize,pBuffer,dwFileSize);
	if( pImageBuffer == NULL ){
		AfxMessageBox(_T("对齐文件内容失败"));
		delete []pBuffer;
		CloseHandle( hFile );
		return dwNewEip;
	}

	//释放内存，关闭文件
	delete []pBuffer;
	CloseHandle( hFile );

	//读入文件成功后，首先处理输入表信息
	if( !ProcessImportTable(pImageBuffer,lpNewImgBase) ){
		AfxMessageBox(_T("处理输入表失败"));
		//VirtualFreeEx(getcurpImageBuffer
		return dwNewEip;

	}

	//继续处理重定位表
	if( !ProcessRelocTable(pImageBuffer,lpNewImgBase) ){
		AfxMessageBox(_T("处理重定位表失败"));
		//VirtualFreeEx pImageBuffer
		return dwNewEip;
	}

	//patch代码
	WriteProcessMemory(hTargetProcess,lpNewImgBase,pImageBuffer,dwSrcImgSize,&dwReadWrite);
	
	//VirtualFreeEx pImageBuffer

	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)( (ULONG)pDosHeader + pDosHeader->e_lfanew );
	dwNewEip=pNtHeaders->OptionalHeader.AddressOfEntryPoint+(DWORD)lpNewImgBase;
	return dwNewEip;
}

/*
输入表处理，一定要注意处理转向的函数，例如kernel32的HeapAlloc实际上转向到ntdll的HeapAlloc
*/
bool ProcessImportTable( PVOID pBaseAddr, PVOID lpNewImgBase )
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddr;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)( (ULONG)pDosHeader + pDosHeader->e_lfanew );

	//获取RtlImageDirectoryEntryToData函数地址
	HMODULE hNtDll = LoadLibrary( _T("ntdll.dll") );
	PRTLIMAGEDIRECTORYENTRYTODATA pRtlImageDirectoryEntryToData = (PRTLIMAGEDIRECTORYENTRYTODATA)GetProcAddress( hNtDll, "RtlImageDirectoryEntryToData" );
	if( pRtlImageDirectoryEntryToData == NULL )
	{
		cout<<"获取RtlImageDirectoryEntryToData函数地址失败"<<endl;
		FreeLibrary( hNtDll );
		return false;
	}
	DWORD dwImportSize = 0;
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)pRtlImageDirectoryEntryToData( pBaseAddr, true, IMAGE_DIRECTORY_ENTRY_IMPORT, &dwImportSize );
	if( pImportDescriptor == NULL )
	{
		cout<<"获取输入表信息出错"<<endl;
		FreeLibrary( hNtDll );
		return false;
	}

	FreeLibrary( hNtDll );


	while( pImportDescriptor->Name != 0 )
	{
		PIMAGE_THUNK_DATA32 pFirstThunkData = (PIMAGE_THUNK_DATA32)( (ULONG)pBaseAddr + pImportDescriptor->FirstThunk);
		PIMAGE_THUNK_DATA32 pOriginalThunkData = (PIMAGE_THUNK_DATA32)( (ULONG)pBaseAddr + pImportDescriptor->OriginalFirstThunk);

		//获取dll名
		char *pDllName = (char*)( (ULONG)pBaseAddr + pImportDescriptor->Name );
		TRACE("处理输入表，DLL：%s\n",pDllName);

		//循环处理该dll中的每个输入表函数
		while( (pOriginalThunkData->u1.Ordinal != 0 ) && !( pOriginalThunkData->u1.Ordinal&0x80000000) )
		{
			PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME)( (ULONG)pBaseAddr + (ULONG)(pOriginalThunkData->u1.AddressOfData) );
			char *pFuncName = (char*)(&pImageImportByName->Name);
			if ( stricmp(pDllName,"SHLWAPI.DLL")==0 ){
				int a=0;
			}
			DWORD dwFuncAddr = GetFuncAddrFromModule( pDllName, pFuncName );
			TRACE("函数名：%s  函数地址：%08X\n",pFuncName,dwFuncAddr);

			if( dwFuncAddr == 0 )
			{
				cout<<"获取输入函数地址出错"<<endl;
				return false;
			}
			*(PULONG)pFirstThunkData = dwFuncAddr;

			pFirstThunkData++;
			pOriginalThunkData++;
		}
		pImportDescriptor++;
	}

	return true;

}

/*
函数描述：获取指定dll模块导出函数地址
参数：
	pDllName:dll模块名
	pFuncName:需要获取地址的函数名
返回值：
	返回函数地址
*/
DWORD GetFuncAddrFromModule( char *pDllName, char *pFuncName )
{
	//首先获取模块基地址,这里pDllName必须是系统已经加载的模块，如果ReloadAndRun的目标文件含有自己的dll，那么就会失败
	

	DWORD dwModuleBase = (DWORD)GetModuleHandleA( pDllName );
	if ( dwModuleBase==NULL ){
		dwModuleBase = (DWORD)LoadLibraryA( pDllName );
	}

	//查找到模块基址后，解析其导出表获取指定函数地址
	//再次获取RtlImageDirectoryEntryToData函数地址
	//获取RtlImageDirectoryEntryToData函数地址
	HMODULE hNtDll = LoadLibrary( _T("ntdll.dll") );
	PRTLIMAGEDIRECTORYENTRYTODATA pRtlImageDirectoryEntryToData = (PRTLIMAGEDIRECTORYENTRYTODATA)GetProcAddress( hNtDll, "RtlImageDirectoryEntryToData" );
	if( pRtlImageDirectoryEntryToData == NULL )
	{
		cout<<"获取RtlImageDirectoryEntryToData函数地址失败"<<endl;
		FreeLibrary( hNtDll );
		return 0;
	}
	DWORD dwExportSize = 0;
	PIMAGE_EXPORT_DIRECTORY pExportDescriptor = (PIMAGE_EXPORT_DIRECTORY)pRtlImageDirectoryEntryToData( (PVOID)dwModuleBase, true, IMAGE_DIRECTORY_ENTRY_EXPORT, &dwExportSize );
	if( pExportDescriptor == NULL )
	{
		cout<<"获取导出表结构失败"<<endl;
		FreeLibrary( hNtDll );
		return 0;
	}
	FreeLibrary( hNtDll );

	//采用而分查找法查找函数地址
	PULONG pNameTableBase = (PULONG)(dwModuleBase + pExportDescriptor->AddressOfNames);
	PUSHORT pNameOrdinalTableBase = (PUSHORT)(dwModuleBase + pExportDescriptor->AddressOfNameOrdinals);

	DWORD dwLow = 0;
	DWORD dwHigh = pExportDescriptor->NumberOfNames - 1;
	DWORD dwMid = 0;
	while( dwLow <= dwHigh )
	{
		dwMid = (dwLow + dwHigh) >> 1;
		LONG lRes = strcmp( (char*)(dwModuleBase+pNameTableBase[dwMid]), pFuncName );
		if( lRes > 0 )
			dwHigh = dwMid - 1;
		else if(lRes < 0 )
			dwLow = dwMid + 1;
		else
			break;
	}
	if( dwLow > dwHigh )
	{
		cout<<"查找函数失败"<<endl;
		return 0;
	}
	DWORD dwOridinalName = pNameOrdinalTableBase[dwMid];
	if( dwOridinalName > pExportDescriptor->NumberOfFunctions )
	{
		cout<<"获取的函数序号错误"<<endl;
		return 0;
	}
	PULONG pAddressTableBase = (PULONG)(dwModuleBase + pExportDescriptor->AddressOfFunctions);
	DWORD dwFuncAddr = dwModuleBase + pAddressTableBase[dwOridinalName];

	//////////////////////////////////////////////////////////////////////////
	//这里简单处理下转向问题
	if ( IsCharAlphaNumeric(*(PCHAR)dwFuncAddr) && IsCharAlphaNumeric(*(PCHAR)(dwFuncAddr+1))
		&& IsCharAlphaNumeric(*(PCHAR)(dwFuncAddr+2)) && IsCharAlphaNumeric(*(PCHAR)(dwFuncAddr+3)) ){
		CString strText=(LPCTSTR)dwFuncAddr;
		int nPos1=strText.Find('.');
		if ( nPos1!=-1 ){
			CString strDllName=strText.Left(nPos1)+".dll";
			CString strFuncName=strText.Mid(nPos1+1);
			dwFuncAddr=(DWORD)GetProcAddress(GetModuleHandleA(strDllName),strFuncName);
		}
	}
	//////////////////////////////////////////////////////////////////////////
	return dwFuncAddr;

}


/*
函数描述：将读出的文件内容按内存对齐格式对齐
参数：
pFileBuffer:文件内容缓冲
返回值：内存对齐后的文件缓冲
*/
PVOID AlignFileToMem(PVOID pImageBuffer,DWORD dwImageSize,PVOID pFileBuffer,DWORD dwFileSize)
{
	//这里有两种方法可以计算对齐后的文件大小：保存在_IMAGE_NT_HEADERS结构中，然后遍历每个节头，根据节头中的节内存偏移拷贝文件内容
	//但有时节表中的节偏移不准确，所以我们这里根据PE文件格式自己计算

	//填充映像内存
	memset( pImageBuffer, 0, dwImageSize );

	//复制PE头信息
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)( (ULONG)pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew );
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)( (ULONG)pNtHeaders + sizeof(IMAGE_NT_HEADERS) );
	DWORD dwCpySize = pNtHeaders->OptionalHeader.SizeOfHeaders;
	for( DWORD dwIndex = 0; dwIndex < pNtHeaders->FileHeader.NumberOfSections; dwIndex++ )
	{
		if( (pSectionHeader[dwIndex].PointerToRawData) != 0 && (pSectionHeader[dwIndex].PointerToRawData<dwCpySize) )
			dwCpySize = pSectionHeader[dwIndex].PointerToRawData;
	}
	memcpy( pImageBuffer, pFileBuffer, dwCpySize );
	PVOID pt = (PVOID)((ULONG)pImageBuffer + GetAlignSize( pNtHeaders->OptionalHeader.SizeOfHeaders, pNtHeaders->OptionalHeader.SectionAlignment ));
	for( DWORD dwIndex = 0; dwIndex < pNtHeaders->FileHeader.NumberOfSections; dwIndex++ )
	{
		if( pSectionHeader[dwIndex].VirtualAddress != 0 )
			pt = (PVOID)( (DWORD)pImageBuffer + pSectionHeader[dwIndex].VirtualAddress);
		if( pSectionHeader[dwIndex].SizeOfRawData != 0 )
		{
			memcpy( pt, (PVOID)( (DWORD)pFileBuffer + pSectionHeader[dwIndex].PointerToRawData), pSectionHeader[dwIndex].SizeOfRawData );
			if( pSectionHeader[dwIndex].SizeOfRawData > pSectionHeader[dwIndex].Misc.VirtualSize )
				pt = (PVOID)( (ULONG)pt + GetAlignSize(pSectionHeader[dwIndex].SizeOfRawData, pNtHeaders->OptionalHeader.SectionAlignment ) );
			else
				pt = (PVOID)( (ULONG)pt + GetAlignSize(pSectionHeader[dwIndex].Misc.VirtualSize, pNtHeaders->OptionalHeader.SectionAlignment ) );

		}
		else
			pt = (PVOID)( (ULONG)pt + GetAlignSize(pSectionHeader[dwIndex].Misc.VirtualSize, pNtHeaders->OptionalHeader.SectionAlignment ) );
	}
	return pImageBuffer;
}

/*
函数说明：计算文件内存对齐后的大小,首先计算文件头对齐值大小，再计算每节的对齐值大小：如果节表中的VirtualAddress非空，VirtualSize非0，则按VirtualSize值计算对齐值
	//如果为0，则按SizeOfRawData计算对齐值；反之，如果VirtualAddress为空，谁大就按谁计算对齐值
参数：
	pFileBuffer:文件内容起始地址
返回值：返回文件内容按内存对齐后的大小
*/
DWORD GetTotalImageSize( PVOID pFileBuffer, DWORD dwFileSize )
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)( (ULONG)pFileBuffer + pDosHeader->e_lfanew );

	DWORD dwTotalSize = GetAlignSize( pNtHeaders->OptionalHeader.SizeOfHeaders, pNtHeaders->OptionalHeader.SectionAlignment );

	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)( (ULONG)pNtHeaders + sizeof(IMAGE_NT_HEADERS) );

	DWORD dwSectionCnt = pNtHeaders->FileHeader.NumberOfSections;
	for( DWORD dwIndex = 0; dwIndex < dwSectionCnt; dwIndex++ )
	{
		if( (pSectionHeader[dwIndex].PointerToRawData + pSectionHeader[dwIndex].SizeOfRawData) > dwFileSize )
		{
			cout<<"文件节表信息由问题"<<endl;
			return 0;
		}
		else if( pSectionHeader[dwIndex].VirtualAddress != NULL )
		{
			if( pSectionHeader[dwIndex].Misc.VirtualSize != 0 )
				dwTotalSize += GetAlignSize( pSectionHeader[dwIndex].Misc.VirtualSize, pNtHeaders->OptionalHeader.SectionAlignment );
			else
				dwTotalSize += GetAlignSize( pSectionHeader[dwIndex].SizeOfRawData, pNtHeaders->OptionalHeader.SectionAlignment );
		}
		else 
		{
			if( pSectionHeader[dwIndex].SizeOfRawData > pSectionHeader[dwIndex].Misc.VirtualSize )
				dwTotalSize += GetAlignSize( pSectionHeader[dwIndex].SizeOfRawData, pNtHeaders->OptionalHeader.SectionAlignment );
			else
				dwTotalSize += GetAlignSize( pSectionHeader[dwIndex].Misc.VirtualSize, pNtHeaders->OptionalHeader.SectionAlignment );
		}
	}
	return dwTotalSize;
}

DWORD GetAlignSize( DWORD dwSize, DWORD dwAlignSize )
{
	return (dwSize+dwAlignSize-1)/dwAlignSize*dwAlignSize;
}

/*
函数说明：处理节内存对齐后文件的重定位表
参数：
	pImageBuffer:对齐后的文件基址
*/
bool ProcessRelocTable( PVOID pImageBuffer, PVOID lpNewImgBase )
{

	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)( (ULONG)pDosHeader + pDosHeader->e_lfanew );

	//获取RtlImageDirectoryEntryToData函数地址
	HMODULE hNtDll = LoadLibrary( _T("ntdll.dll") );
	PRTLIMAGEDIRECTORYENTRYTODATA pRtlImageDirectoryEntryToData = (PRTLIMAGEDIRECTORYENTRYTODATA)GetProcAddress( hNtDll, "RtlImageDirectoryEntryToData" );
	if( pRtlImageDirectoryEntryToData == NULL )
	{
		cout<<"获取RtlImageDirectoryEntryToData函数地址失败"<<endl;
		FreeLibrary( hNtDll );
		return false;
	}
	DWORD dwRelocSize = 0; 
	PIMAGE_BASE_RELOCATION pRelocDescriptor = (PIMAGE_BASE_RELOCATION)pRtlImageDirectoryEntryToData( pImageBuffer, true, IMAGE_DIRECTORY_ENTRY_BASERELOC, &dwRelocSize );
	if( pRelocDescriptor == NULL )
	{
		FreeLibrary( hNtDll );
		cout<<"无重定位表"<<endl;
		return true;
	}
	FreeLibrary( hNtDll );

	DWORD dwRelocaSize = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
	DWORD dwDelta = (DWORD)lpNewImgBase - pNtHeaders->OptionalHeader.ImageBase;
	while( dwRelocaSize > 0 )
	{
		PUSHORT pFixup = (PUSHORT)((ULONG)pRelocDescriptor + sizeof(IMAGE_BASE_RELOCATION));
		for( DWORD dwIndex = 0; dwIndex< ( (pRelocDescriptor->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2 ); dwIndex++ )
		{
			
			if( (pFixup[dwIndex]>>12) == IMAGE_REL_BASED_HIGHLOW )
			{
				DWORD dwAddr = (DWORD)pImageBuffer + pRelocDescriptor->VirtualAddress + (pFixup[dwIndex]&0xfff);
				*(PULONG)dwAddr += dwDelta;
			}
			
			//DWORD dwAddr = (DWORD)pImageBuffer + pRelocDescriptor->VirtualAddress + (pFixup[dwIndex]&0xfff);
		//	*(PULONG)dwAddr += dwDelta;
		}
		dwRelocaSize -= pRelocDescriptor->SizeOfBlock;
		pRelocDescriptor = (PIMAGE_BASE_RELOCATION)((ULONG)pRelocDescriptor + pRelocDescriptor->SizeOfBlock);
	}
	return true;

}