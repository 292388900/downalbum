t_disasm.op[3]存储操作数

t_disasm.op[i].opsize一般为4，代表4字节寻址方式

t_disasm.op[0].opsize==0 	//0操作数
t_disasm.op[1].opsize==0 	//1操作数
t_disasm.op[2].opsize==0 	//2操作数
都不为0				//3操作数

t_disasm.op[i].optype==0x24	//操作数为寄存器(4)，头文件中没有定义
t_disasm.op[i].optype==0x21	//操作数为寄存器(1)，头文件中没有定义
t_disasm.op[i].optype==0x04	//DEC_DWORD 4字节地址寻址方式
t_disasm.op[i].opconst		//指示了该操作数中包含的常数

#define DEC_TYPEMASK   0x1F            // Type of memory byte
#define   DEC_UNKNOWN  0x00            // Unknown type
#define   DEC_BYTE     0x01            // Accessed as byte
#define   DEC_WORD     0x02            // Accessed as short
#define   DEC_NEXTDATA 0x03            // Subsequent byte of data
#define   DEC_DWORD    0x04            // Accessed as long
#define   DEC_FLOAT4   0x05            // Accessed as float
#define   DEC_FWORD    0x06            // Accessed as descriptor/long pointer
#define   DEC_FLOAT8   0x07            // Accessed as double
#define   DEC_QWORD    0x08            // Accessed as 8-byte integer
#define   DEC_FLOAT10  0x09            // Accessed as long double
#define   DEC_TBYTE    0x0A            // Accessed as 10-byte integer
#define   DEC_STRING   0x0B            // Zero-terminated ASCII string
#define   DEC_UNICODE  0x0C            // Zero-terminated UNICODE string
#define   DEC_3DNOW    0x0D            // Accessed as 3Dnow operand
#define   DEC_SSE      0x0E            // Accessed as SSE operand
#define   DEC_TEXT     0x10            // For use in t_result only
#define   DEC_BYTESW   0x11            // Accessed as byte index to switch
#define   DEC_NEXTCODE 0x13            // Subsequent byte of command
#define   DEC_COMMAND  0x1D            // First byte of command
#define   DEC_JMPDEST  0x1E            // Jump destination
#define   DEC_CALLDEST 0x1F            // Call (and maybe jump) destination
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PBODY    0x40            // Body of procedure
#define   DEC_PEND     0x60            // End of procedure
#define DEC_CHECKED    0x80            // Byte was analysed
#define DEC_SIGNED     0x100           // For use in t_result only



t_disasm.op[i].seg指示使用的是哪个段，例如mov eax,dword ptr ss:[ebp+14]的操作数2的段为2

#define SEG_UNDEF     -1
#define SEG_ES         0               // Indexes of segment/selector registers
#define SEG_CS         1               // in t_reg.
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5


mov byte ptr ds:[eax+14],cl
t_disasm.op[i].seg=3			//SEG_DS


mov eax,dword ptr ss:[ebp+14]
t_disasm.adrconst为14


lea edi,dword ptr ds:[esi+FFF8B000]

识别操作数2段为SEG_DS，并且t_disasm.op[i].optype=DEC_UNKNOWN，说明寻址方式不常见 常数不显示为金色 则为蓝字



cmp byte ptr ss:[esp+8],1
操作数1的optype=DEC_BYTE，段为2说明是堆栈相关的 蓝底
操作数2的optype=40 头文件未定义，理解为常数 段为SEG_UNDEF，说明无段


xor eax,FFFFFFFF



lea edx,dword ptr ds:[edi+ebp]


