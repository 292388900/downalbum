先说3种方法
代码：

#include <windows.h>
#include <stdio.h>

BOOL gInVMWARE, gInVirtualPC;

BOOL VMWareTest()
{
BYTE PortValue1,PortValue2;
__try
{
    __asm
    {
      pushad 
      pushfd
      xor ebx,ebx
      mov ecx,0xa 
      mov eax, 'VMXh'        ; EAX=magic    //564D5868
      mov dx, 'VX'            ; DX=magic
      in eax, dx            ; specially processed io cmd
      cmp ebx, 'VMXh'        ; also eax/ecx modified (maybe vmw/os ver?)
      sete al;
    movzx eax, al
      mov gInVMWARE, eax;
      popfd
      popad
    }
}
__except(EXCEPTION_EXECUTE_HANDLER)
{
    gInVMWARE=FALSE;
}
return gInVMWARE;
}

BOOL VirtualPCTest()
{
__try
{
    __asm
    {
      pushad      
      mov ebx, 0 // Flag
      mov eax, 1 // VPC function number
      __emit 0Fh
      __emit 3Fh
      __emit 07h
      __emit 0Bh
      test ebx, ebx
    sete al
    movzx eax, al
      mov gInVirtualPC , eax;
      popad
    }

}
__except(EXCEPTION_EXECUTE_HANDLER)
{
    gInVirtualPC=FALSE;
}
return gInVirtualPC;
}

BOOL VMTest()
{
    ULONG xdt = 0 ;
    ULONG InVM = 0;
    __asm
    {
        push edx
            sidt [esp-2]
            pop edx
            nop
            mov xdt , edx
    }
    printf("idt = %08x\n" , xdt);
    if (xdt > 0xd0000000)
    {
        //printf("IDT Test :running in vm!\n");
        InVM = 1;
    }
    else
    {
        InVM = 0;
    }
    __asm
    {
        push edx
            sgdt [esp-2]
            pop edx
            nop
            mov xdt , edx
    }
    
    printf("gdt = %08x\n" , xdt);
    
    if (xdt > 0xd0000000)
    {
        InVM += 1;
    }
    else
    {
        InVM += 0;
    }
    return InVM;
}

int main()
{
    if (VMWareTest())
    {
        printf("In Vmware !!!");
    }
    else if (VirtualPCTest())
    {
        printf("In VirtualPC!!!!");
    }
    else if (VMTest())
    {
        printf("In VM !");
    }
    else
    {
        printf("In Host!");
    }
    
    getchar ();
    return 1;
}

OK，这样VMWare里面基本都能检测到
检测虚拟机，一般来说有3种方法：
1，是猥琐法，比如系统中有没有vmware类似的服务，进程等，检查BIOS的信息，虚拟设备的名称等等，这种方法是很猥琐的，优点是防不胜防，缺点就是不准确，而且都能修改（注意：BIOS也是能修改的）。
2，是模拟漏洞法，由于虚拟机毕竟不是真机，模拟上面是有一定的漏洞的，上面的VMTest就是漏洞法。优点是准确，基本上100%可以确定，因为是模拟的漏洞，所以不容易修改，缺点基本上没有。
3，是后门法，虚拟机需要和host进行通讯，利用通讯检测虚拟机，如上面的那个VMWare.GetVersion的后门。优点是准确，缺点是可以屏蔽掉后门。

所以，一般来说都是用后门法，高级一点用模拟漏洞。

随着硬件虚拟化技术的迅猛发展，模拟的漏洞越来越少，开了VT功能后，使用VMWare 6.0以上基本上灭掉了所有模拟的漏洞，后门法，patch一下主程序和guest的tools。

下面图是我修改过的开了VT-x的VMWare，用上面的代码是检测不出来的





注意红框，如果修改配置文件屏蔽后门，vmware tools是无法启动的。我这里是Patch了Vmware tools和vmware-vmx.exe的主程序实现的，后来想想，还是避不开猥琐的校验。。

能过99%的anti vmware，主要还是靠VT技术，实在太强大了。

由于某些原因，上面的模拟漏洞我只贴了MJ0011的代码，还有几个漏洞（暂时不公开写出来，当然无法对付VMWare的）可以对付其他几款虚拟机，比如VBox（开了VT也被检测）。 

